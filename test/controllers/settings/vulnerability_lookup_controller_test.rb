# frozen_string_literal: true

require 'test_helper'

module Settings
  class VulnerabilityLookupControllerTest < ActionDispatch::IntegrationTest
    setup do
      @admin = users(:admin)
      sign_in @admin
    end

    # Test Group 1.1: Tests for get_python_environment_info method

    test 'get_python_environment_info returns success with version when Python and PyVulnerabilityLookup installed' do
      # Mock Python path to exist
      python_path = '/opt/veracity/app/integrations_venv/bin/python'
      SystemSetting.stubs(:get).with('vulnerability_lookup_python_path', '/opt/veracity/app/integrations_venv/bin/python').returns(python_path)
      File.stubs(:exist?).with(python_path).returns(true)

      # Mock tempfile
      mock_tempfile = mock('tempfile')
      mock_tempfile.stubs(:write)
      mock_tempfile.stubs(:close)
      mock_tempfile.stubs(:path).returns('/tmp/pyvuln_check.py')
      mock_tempfile.stubs(:unlink)
      Tempfile.stubs(:new).returns(mock_tempfile)

      # Mock successful Python script execution with version info
      mock_stdout = {
        success: true,
        version: '1.2.3',
        python_version: '3.9.0'
      }.to_json

      mock_status = mock('status')
      mock_status.stubs(:success?).returns(true)

      Open3.stubs(:capture3).with(python_path, '/tmp/pyvuln_check.py').returns([mock_stdout, '', mock_status])
      Timeout.stubs(:timeout).yields

      controller = Settings::VulnerabilityLookupController.new
      result = controller.send(:get_python_environment_info)

      assert result[:available]
      assert_equal '1.2.3', result[:pyvulnerabilitylookup_version]
      assert_equal python_path, result[:python_path]
      assert_match(/configured correctly/, result[:message])
    end

    test 'get_python_environment_info returns failure with clear error when PyVulnerabilityLookup not installed' do
      # Mock Python path to exist
      python_path = '/opt/veracity/app/integrations_venv/bin/python'
      SystemSetting.stubs(:get).with('vulnerability_lookup_python_path', '/opt/veracity/app/integrations_venv/bin/python').returns(python_path)
      File.stubs(:exist?).with(python_path).returns(true)

      # Mock tempfile
      mock_tempfile = mock('tempfile')
      mock_tempfile.stubs(:write)
      mock_tempfile.stubs(:close)
      mock_tempfile.stubs(:path).returns('/tmp/pyvuln_check.py')
      mock_tempfile.stubs(:unlink)
      Tempfile.stubs(:new).returns(mock_tempfile)

      # Mock Python script execution with import error
      mock_stdout = {
        success: false,
        error: "No module named 'pyvulnerabilitylookup'",
        python_version: '3.9.0'
      }.to_json

      mock_status = mock('status')
      mock_status.stubs(:success?).returns(true)

      Open3.stubs(:capture3).with(python_path, '/tmp/pyvuln_check.py').returns([mock_stdout, '', mock_status])
      Timeout.stubs(:timeout).yields

      controller = Settings::VulnerabilityLookupController.new
      result = controller.send(:get_python_environment_info)

      assert_not result[:available]
      assert_nil result[:pyvulnerabilitylookup_version]
      assert_match(/PyVulnerabilityLookup is not installed/, result[:message])
      assert_match(/pip install pyvulnerabilitylookup/, result[:message])
    end

    test 'get_python_environment_info uses fallback logic when invalid Python path configured' do
      # Mock configured path doesn't exist
      configured_path = '/invalid/path/to/python'
      venv_path = '/opt/veracity/app/integrations_venv/bin/python'

      SystemSetting.stubs(:get).with('vulnerability_lookup_python_path', '/opt/veracity/app/integrations_venv/bin/python').returns(configured_path)
      File.stubs(:exist?).with(configured_path).returns(false)
      File.stubs(:exist?).with(venv_path).returns(true)

      # Mock tempfile
      mock_tempfile = mock('tempfile')
      mock_tempfile.stubs(:write)
      mock_tempfile.stubs(:close)
      mock_tempfile.stubs(:path).returns('/tmp/pyvuln_check.py')
      mock_tempfile.stubs(:unlink)
      Tempfile.stubs(:new).returns(mock_tempfile)

      # Mock successful execution with fallback path
      mock_stdout = {
        success: true,
        version: '1.2.3',
        python_version: '3.9.0'
      }.to_json

      mock_status = mock('status')
      mock_status.stubs(:success?).returns(true)

      Open3.stubs(:capture3).with(venv_path, '/tmp/pyvuln_check.py').returns([mock_stdout, '', mock_status])
      Timeout.stubs(:timeout).yields

      controller = Settings::VulnerabilityLookupController.new
      result = controller.send(:get_python_environment_info)

      # Should use venv fallback path
      assert_equal venv_path, result[:python_path]
      assert result[:available]
    end

    test 'get_python_environment_info handles timeout gracefully' do
      python_path = '/opt/veracity/app/integrations_venv/bin/python'
      SystemSetting.stubs(:get).with('vulnerability_lookup_python_path', '/opt/veracity/app/integrations_venv/bin/python').returns(python_path)
      File.stubs(:exist?).with(python_path).returns(true)

      # Mock tempfile
      mock_tempfile = mock('tempfile')
      mock_tempfile.stubs(:write)
      mock_tempfile.stubs(:close)
      mock_tempfile.stubs(:path).returns('/tmp/pyvuln_check.py')
      mock_tempfile.expects(:unlink).once  # Verify cleanup on timeout
      Tempfile.stubs(:new).returns(mock_tempfile)

      # Mock timeout error
      Timeout.stubs(:timeout).raises(Timeout::Error)

      controller = Settings::VulnerabilityLookupController.new
      result = controller.send(:get_python_environment_info)

      assert_not result[:available]
      assert_match(/timeout|timed out/i, result[:message])
    end

    test 'get_python_environment_info cleans up tempfile even on error' do
      python_path = '/opt/veracity/app/integrations_venv/bin/python'
      SystemSetting.stubs(:get).with('vulnerability_lookup_python_path', '/opt/veracity/app/integrations_venv/bin/python').returns(python_path)
      File.stubs(:exist?).with(python_path).returns(true)

      # Create a mock tempfile to track cleanup
      mock_tempfile = mock('tempfile')
      mock_tempfile.stubs(:write)
      mock_tempfile.stubs(:close)
      mock_tempfile.stubs(:path).returns('/tmp/pyvuln_check.py')
      mock_tempfile.expects(:unlink).once  # Verify cleanup is called

      Tempfile.stubs(:new).returns(mock_tempfile)

      # Mock execution to raise an error
      Timeout.stubs(:timeout).yields
      Open3.stubs(:capture3).raises(StandardError.new('Execution failed'))

      controller = Settings::VulnerabilityLookupController.new
      result = controller.send(:get_python_environment_info)

      # Should return error result
      assert_not result[:available]
      assert_match(/Execution failed/, result[:message])
    end

    # ===========================================
    # Task Group 4: Strategic Coverage Gap Tests
    # ===========================================

    test 'get_python_environment_info handles JSON parse error from malformed Python output' do
      # Critical Gap #1: Test JSON parse error handling (controller lines 314-323)
      python_path = '/opt/veracity/app/integrations_venv/bin/python'
      SystemSetting.stubs(:get).with('vulnerability_lookup_python_path', '/opt/veracity/app/integrations_venv/bin/python').returns(python_path)
      File.stubs(:exist?).with(python_path).returns(true)

      # Mock tempfile
      mock_tempfile = mock('tempfile')
      mock_tempfile.stubs(:write)
      mock_tempfile.stubs(:close)
      mock_tempfile.stubs(:path).returns('/tmp/pyvuln_check.py')
      mock_tempfile.stubs(:unlink)
      Tempfile.stubs(:new).returns(mock_tempfile)

      # Mock Python script execution that returns malformed JSON
      malformed_output = "INVALID JSON {not: valid"
      mock_stderr = "SyntaxError: invalid syntax"
      mock_status = mock('status')
      mock_status.stubs(:success?).returns(true)

      Open3.stubs(:capture3).with(python_path, '/tmp/pyvuln_check.py').returns([malformed_output, mock_stderr, mock_status])
      Timeout.stubs(:timeout).yields

      # Mock logger to prevent noise in test output
      Rails.logger.stubs(:error)

      controller = Settings::VulnerabilityLookupController.new
      result = controller.send(:get_python_environment_info)

      # Should gracefully handle JSON parse error
      assert_not result[:available]
      assert_nil result[:pyvulnerabilitylookup_version]
      assert_match(/Failed to parse Python script output/, result[:message])
      assert_match(/#{mock_stderr}/, result[:message])
    end

    test 'get_python_environment_info returns clear error when all Python paths fail' do
      # Critical Gap #5: Test when resolve_python_path returns nil (lines 240-248)
      configured_path = '/invalid/configured/python'
      venv_path = '/opt/veracity/app/integrations_venv/bin/python'

      SystemSetting.stubs(:get).with('vulnerability_lookup_python_path', '/opt/veracity/app/integrations_venv/bin/python').returns(configured_path)
      File.stubs(:exist?).with(configured_path).returns(false)
      File.stubs(:exist?).with(venv_path).returns(false)

      # Mock 'which python3' to also fail
      mock_status = mock('status')
      mock_status.stubs(:success?).returns(false)
      Open3.stubs(:capture3).with('which', 'python3').returns(['', '', mock_status])

      controller = Settings::VulnerabilityLookupController.new
      result = controller.send(:get_python_environment_info)

      # Should return error with clear message about Python not being configured
      assert_not result[:available]
      assert_nil result[:python_path]
      assert_nil result[:python_version]
      assert_nil result[:pyvulnerabilitylookup_version]
      assert_match(/Python not configured or missing/, result[:message])
      assert_match(/Please set Python path in settings/, result[:message])
    end

    test 'resolve_python_path falls back to system python3 when configured and venv paths fail' do
      # Critical Gap #4: Test fallback to system python3 (resolve_python_path lines 357-359)
      configured_path = '/invalid/configured/python'
      venv_path = '/opt/veracity/app/integrations_venv/bin/python'
      system_python = '/usr/bin/python3'

      SystemSetting.stubs(:get).with('vulnerability_lookup_python_path', '/opt/veracity/app/integrations_venv/bin/python').returns(configured_path)
      File.stubs(:exist?).with(configured_path).returns(false)
      File.stubs(:exist?).with(venv_path).returns(false)
      File.stubs(:exist?).with(system_python).returns(true)

      # Mock 'which python3' to return system python
      mock_status = mock('status')
      mock_status.stubs(:success?).returns(true)
      Open3.stubs(:capture3).with('which', 'python3').returns([system_python, '', mock_status])

      controller = Settings::VulnerabilityLookupController.new
      result = controller.send(:resolve_python_path)

      # Should fallback to system python3
      assert_equal system_python, result
    end

    test 'get_python_environment_info handles permission denied errors gracefully' do
      # Critical Gap #3: Test permission errors when executing Python
      python_path = '/opt/veracity/app/integrations_venv/bin/python'
      SystemSetting.stubs(:get).with('vulnerability_lookup_python_path', '/opt/veracity/app/integrations_venv/bin/python').returns(python_path)
      File.stubs(:exist?).with(python_path).returns(true)

      # Mock tempfile
      mock_tempfile = mock('tempfile')
      mock_tempfile.stubs(:write)
      mock_tempfile.stubs(:close)
      mock_tempfile.stubs(:path).returns('/tmp/pyvuln_check.py')
      mock_tempfile.expects(:unlink).once  # Verify cleanup on error
      Tempfile.stubs(:new).returns(mock_tempfile)

      # Mock execution to raise permission error
      Timeout.stubs(:timeout).yields
      permission_error = Errno::EACCES.new('Permission denied')
      Open3.stubs(:capture3).raises(permission_error)

      # Mock logger to prevent noise in test output
      Rails.logger.stubs(:error)

      controller = Settings::VulnerabilityLookupController.new
      result = controller.send(:get_python_environment_info)

      # Should gracefully handle permission error with clear message
      assert_not result[:available]
      assert_match(/Python environment error/, result[:message])
      assert_match(/Permission denied/, result[:message])
    end
  end
end
