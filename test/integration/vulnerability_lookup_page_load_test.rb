# frozen_string_literal: true

require "test_helper"

# Integration tests for Vulnerability Lookup Settings Page Load Consistency
# These tests verify that the page load status indicators match the button test results,
# ensuring the fix for the false negative status indicators is working correctly.
class VulnerabilityLookupPageLoadTest < ActionDispatch::IntegrationTest
  setup do
    @admin = users(:admin)
    sign_in @admin
  end

  # ===========================================
  # Task 3.1: Page Load Consistency Tests
  # ===========================================

  test "page load status matches Check Python Environment button result" do
    # Clear cache to ensure fresh status check
    Rails.cache.clear

    # Load the page and capture initial status
    get settings_vulnerability_lookup_path
    assert_response :success

    # Extract page load status from instance variables
    page_load_python_info = assigns(:python_info)
    assert_not_nil page_load_python_info, "Expected @python_info to be set on page load"

    # Simulate clicking "Check Python Environment" button by calling the same endpoint
    post python_info_settings_vulnerability_lookup_path, xhr: true
    assert_response :success

    # Parse button result
    button_result = JSON.parse(response.body)

    # Verify button result matches page load status
    assert_equal page_load_python_info[:available], button_result['success'],
                 "Page load available status should match button result success"
    assert_equal page_load_python_info[:python_version], button_result['python_version'],
                 "Page load Python version should match button result"
    assert_equal page_load_python_info[:pyvulnerabilitylookup_version], button_result['pyvulnerabilitylookup_version'],
                 "Page load PyVulnLookup version should match button result"
  end

  test "page load shows green checkmarks when PyVulnerabilityLookup is installed" do
    # Mock successful Python environment (library installed)
    controller = Settings::VulnerabilityLookupController.new

    mock_python_info = {
      available: true,
      python_path: '/opt/veracity/app/integrations_venv/bin/python',
      python_version: '3.9.0',
      pyvulnerabilitylookup_version: '1.2.3',
      message: 'Python environment is configured correctly'
    }

    Settings::VulnerabilityLookupController.any_instance
      .stubs(:get_python_environment_info)
      .returns(mock_python_info)

    # Load the page
    get settings_vulnerability_lookup_path
    assert_response :success

    # Verify instance variables show success status
    python_info = assigns(:python_info)
    assert python_info[:available], "Expected Python to be available"
    assert_equal '1.2.3', python_info[:pyvulnerabilitylookup_version], "Expected PyVulnLookup version"

    # Verify the view renders success indicators
    assert_select 'span.text-success', { text: /✓ Configured/ },
                  "Expected green checkmark for Python status"
    assert_select 'span.text-success', { text: /✓ v1\.2\.3/ },
                  "Expected green checkmark with version for PyVulnLookup status"
  end

  test "page load status matches Test API Connection button result when library installed" do
    # Skip if Python/pyvulnerabilitylookup not actually available on system
    skip "Python 3 with pyvulnerabilitylookup not available" unless python_available?

    # Clear cache to ensure fresh status check
    Rails.cache.clear

    # Load the page and capture initial status
    get settings_vulnerability_lookup_path
    assert_response :success

    page_load_python_info = assigns(:python_info)
    assert_not_nil page_load_python_info

    # If page load shows library is installed, test API connection should work
    if page_load_python_info[:pyvulnerabilitylookup_version].present?
      # Simulate clicking "Test API Connection" button
      post test_connection_settings_vulnerability_lookup_path, xhr: true

      # If page load shows library installed, API test should succeed (not fail with import error)
      api_result = JSON.parse(response.body)

      # The API test should either succeed OR fail with a non-import error (network/API issues)
      # It should NOT fail with "PyVulnerabilityLookup is not installed" error
      if api_result['success'] == false
        refute_match(/not installed|module named/i, api_result['message'],
                     "API test failed with import error, but page load showed library installed")
      end
    end
  end

  test "page load shows red X with correct error when PyVulnerabilityLookup not installed" do
    # Mock failed Python environment (library not installed)
    mock_python_info = {
      available: false,
      python_path: '/opt/veracity/app/integrations_venv/bin/python',
      python_version: '3.9.0',
      pyvulnerabilitylookup_version: nil,
      message: 'PyVulnerabilityLookup is not installed. Run: pip install pyvulnerabilitylookup'
    }

    Settings::VulnerabilityLookupController.any_instance
      .stubs(:get_python_environment_info)
      .returns(mock_python_info)

    # Load the page
    get settings_vulnerability_lookup_path
    assert_response :success

    # Verify instance variables show failure status
    python_info = assigns(:python_info)
    assert_not python_info[:available], "Expected Python to be unavailable"
    assert_nil python_info[:pyvulnerabilitylookup_version], "Expected no PyVulnLookup version"

    # Verify the view renders error indicators
    assert_select 'span.text-error', { text: /✗ Not installed/ },
                  "Expected red X for PyVulnLookup status when not installed"
  end

  # ===========================================
  # Task 3.4: Migration Auto-Population Test
  # ===========================================

  test "migration auto-populates Python path when venv exists" do
    # This test verifies the migration created in Task Group 2 works correctly

    # Remove the setting if it exists
    existing_setting = SystemSetting.find_by(key: 'vulnerability_lookup_python_path')
    existing_setting.destroy if existing_setting

    # Verify setting doesn't exist
    assert_nil SystemSetting.find_by(key: 'vulnerability_lookup_python_path'),
               "Setting should not exist before migration"

    # Manually run the migration's up method
    # Note: We can't actually run the migration file, but we can test the logic
    venv_path = '/opt/veracity/app/integrations_venv/bin/python'

    if File.exist?(venv_path)
      # Simulate what the migration does
      SystemSetting.find_or_create_by!(key: 'vulnerability_lookup_python_path') do |setting|
        setting.value = venv_path
        setting.value_type = 'string'
      end

      # Verify setting was created
      created_setting = SystemSetting.find_by(key: 'vulnerability_lookup_python_path')
      assert_not_nil created_setting, "Setting should be created when venv exists"
      assert_equal venv_path, created_setting.value, "Setting should have venv path value"

      # Reload settings page and confirm status shows correctly
      Rails.cache.clear
      get settings_vulnerability_lookup_path
      assert_response :success

      # The page should now be able to find Python
      python_info = assigns(:python_info)
      assert_not_nil python_info[:python_path], "Should have Python path after migration"
    else
      skip "Venv does not exist at #{venv_path}, cannot test auto-population"
    end
  end

  # ===========================================
  # Task Group 4: Strategic Coverage Gap Test
  # ===========================================

  test "migration handles gracefully when venv does not exist" do
    # Critical Gap #2: Test migration behavior when venv path doesn't exist
    # This simulates a fresh installation where Python venv hasn't been created yet

    # Remove the setting if it exists
    existing_setting = SystemSetting.find_by(key: 'vulnerability_lookup_python_path')
    existing_setting.destroy if existing_setting

    venv_path = '/opt/veracity/app/integrations_venv/bin/python'

    # Only run this test if venv doesn't exist (or mock it)
    # In production CI this may always pass if venv exists
    unless File.exist?(venv_path)
      # Simulate migration behavior when venv doesn't exist
      # Migration should skip auto-population without error

      # The setting should remain nil/not exist
      assert_nil SystemSetting.find_by(key: 'vulnerability_lookup_python_path'),
                 "Setting should not be created when venv doesn't exist"

      # Page should still load without crashing
      Rails.cache.clear
      get settings_vulnerability_lookup_path
      assert_response :success

      # Should show appropriate error about Python not being configured
      python_info = assigns(:python_info)
      assert_not_nil python_info, "Should have python_info even when venv missing"
      # Either python_path is nil, or it found system python3 as fallback
      if python_info[:python_path].nil?
        assert_not python_info[:available], "Should show Python as unavailable when no path found"
      end
    else
      # If venv exists, we can still test by using a non-existent path
      fake_path = '/nonexistent/fake/python'

      # Simulate checking if fake path exists
      assert_not File.exist?(fake_path), "Fake path should not exist"

      # Migration would skip this path and not create setting
      # This validates the File.exist? check in migration works correctly
      skip "Venv exists, migration edge case already covered by main migration test"
    end
  end

  # ===========================================
  # Helper Methods
  # ===========================================

  private

  def python_available?
    # Check for Python 3
    return false unless system("python3 --version > /dev/null 2>&1")

    # Check for pyvulnerabilitylookup
    system("python3 -c 'import pyvulnerabilitylookup' 2>/dev/null")
  end
end
