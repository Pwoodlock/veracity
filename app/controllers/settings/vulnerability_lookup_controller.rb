# frozen_string_literal: true

require 'open3'
require 'timeout'
require 'tempfile'
require 'json'

module Settings
  class VulnerabilityLookupController < ApplicationController
    before_action :authenticate_user!
    before_action :authorize_admin!

    def index
      # Get settings with source tracking (ENV vs DB)
      @vulnerability_lookup_url = SystemSetting.get_with_source('vulnerability_lookup_url', 'https://vulnerability.circl.lu')
      @vulnerability_lookup_enabled = SystemSetting.get_with_source('vulnerability_lookup_enabled', true)
      @vulnerability_lookup_scan_schedule = SystemSetting.get_with_source('vulnerability_lookup_scan_schedule', '0 2 * * *')
      @vulnerability_lookup_notification_threshold = SystemSetting.get_with_source('vulnerability_lookup_notification_threshold', 'high')
      @vulnerability_lookup_python_path = SystemSetting.get_with_source('vulnerability_lookup_python_path', '/opt/veracity/app/integrations_venv/bin/python')
      @vulnerability_lookup_timeout = SystemSetting.get_with_source('vulnerability_lookup_timeout', 120)

      # Get Python environment info
      @python_info = get_python_environment_info

      # Get recent CVE scan statistics
      @recent_scans = CveScanHistory.order(created_at: :desc).limit(10)
      @total_vulnerabilities = VulnerabilityAlert.count
      @critical_vulnerabilities = VulnerabilityAlert.where(severity: 'CRITICAL').count
      @high_vulnerabilities = VulnerabilityAlert.where(severity: 'HIGH').count
      @active_watchlists = CveWatchlist.where(active: true).count

      # Get notification threshold options
      @threshold_options = [
        ['All Severities (INFO and above)', 'info'],
        ['LOW and above', 'low'],
        ['MEDIUM and above', 'medium'],
        ['HIGH and above', 'high'],
        ['CRITICAL only', 'critical']
      ]
    end

    def update
      begin
        # Check if any ENV overrides are active
        env_overrides = []
        env_overrides << 'API URL' if SystemSetting.env_override?('vulnerability_lookup_url')
        env_overrides << 'Enabled' if SystemSetting.env_override?('vulnerability_lookup_enabled')
        env_overrides << 'Scan Schedule' if SystemSetting.env_override?('vulnerability_lookup_scan_schedule')
        env_overrides << 'Notification Threshold' if SystemSetting.env_override?('vulnerability_lookup_notification_threshold')
        env_overrides << 'Python Path' if SystemSetting.env_override?('vulnerability_lookup_python_path')
        env_overrides << 'Timeout' if SystemSetting.env_override?('vulnerability_lookup_timeout')

        if env_overrides.any?
          flash[:warning] = "Some settings (#{env_overrides.join(', ')}) are controlled by environment variables and cannot be changed via UI."
          redirect_to settings_vulnerability_lookup_path
          return
        end

        # Update API URL
        if params[:vulnerability_lookup_url].present?
          url = sanitize_url(params[:vulnerability_lookup_url])
          SystemSetting.set('vulnerability_lookup_url', url, 'string')
        end

        # Update enabled status
        enabled = params[:vulnerability_lookup_enabled] == '1' || params[:vulnerability_lookup_enabled] == 'true'
        SystemSetting.set('vulnerability_lookup_enabled', enabled, 'boolean')

        # Update scan schedule (validate cron expression)
        if params[:vulnerability_lookup_scan_schedule].present?
          schedule = params[:vulnerability_lookup_scan_schedule].strip
          if valid_cron_expression?(schedule)
            SystemSetting.set('vulnerability_lookup_scan_schedule', schedule, 'string')
          else
            flash[:error] = 'Invalid cron expression. Please use a valid format (e.g., "0 2 * * *" for daily at 2 AM).'
            redirect_to settings_vulnerability_lookup_path
            return
          end
        end

        # Update notification threshold
        if params[:vulnerability_lookup_notification_threshold].present?
          threshold = params[:vulnerability_lookup_notification_threshold]
          if %w[info low medium high critical].include?(threshold)
            SystemSetting.set('vulnerability_lookup_notification_threshold', threshold, 'string')
          else
            flash[:error] = 'Invalid notification threshold value.'
            redirect_to settings_vulnerability_lookup_path
            return
          end
        end

        # Update Python path
        if params[:vulnerability_lookup_python_path].present?
          python_path = params[:vulnerability_lookup_python_path].strip
          SystemSetting.set('vulnerability_lookup_python_path', python_path, 'string')
        end

        # Update timeout
        if params[:vulnerability_lookup_timeout].present?
          timeout = params[:vulnerability_lookup_timeout].to_i
          if timeout > 0 && timeout <= 600
            SystemSetting.set('vulnerability_lookup_timeout', timeout, 'integer')
          else
            flash[:error] = 'Timeout must be between 1 and 600 seconds.'
            redirect_to settings_vulnerability_lookup_path
            return
          end
        end

        # Restart scheduled jobs if schedule changed
        if params[:vulnerability_lookup_scan_schedule].present?
          restart_scheduler if defined?(Sidekiq)
        end

        flash[:notice] = 'Vulnerability Lookup settings updated successfully'
        redirect_to settings_vulnerability_lookup_path
      rescue StandardError => e
        Rails.logger.error "Failed to update Vulnerability Lookup settings: #{e.message}"
        flash[:error] = "Failed to update settings: #{e.message}"
        redirect_to settings_vulnerability_lookup_path
      end
    end

    def test_connection
      begin
        url = SystemSetting.get('vulnerability_lookup_url', 'https://vulnerability.circl.lu')
        timeout = SystemSetting.get('vulnerability_lookup_timeout', 120)

        # Test the API by checking if it's responding
        result = CveMonitoringService.test_api_connection(url, timeout)

        if result[:success]
          render json: {
            success: true,
            message: "Connection successful! API is responding.",
            api_version: result[:version],
            library_version: result[:library_version],
            api_info: result[:api_info]
          }
        else
          render json: {
            success: false,
            message: result[:message] || 'Connection test failed'
          }, status: :unprocessable_entity
        end
      rescue StandardError => e
        Rails.logger.error "Vulnerability Lookup connection test failed: #{e.message}"
        render json: {
          success: false,
          message: "Connection test failed: #{e.message}"
        }, status: :unprocessable_entity
      end
    end

    def python_info
      begin
        info = get_python_environment_info

        render json: {
          success: info[:available],
          python_version: info[:python_version],
          pyvulnerabilitylookup_version: info[:pyvulnerabilitylookup_version],
          python_path: info[:python_path],
          message: info[:message]
        }
      rescue StandardError => e
        Rails.logger.error "Failed to get Python info: #{e.message}"
        render json: {
          success: false,
          message: "Failed to get Python info: #{e.message}"
        }, status: :unprocessable_entity
      end
    end

    def run_scan
      begin
        unless SystemSetting.get('vulnerability_lookup_enabled', true)
          redirect_to settings_vulnerability_lookup_path, alert: 'CVE scanning is disabled. Please enable it first.'
          return
        end

        # Run the scan in the background via Sidekiq
        CveScanJob.perform_later

        flash[:notice] = 'CVE scan has been queued and will run in the background. Check the scan history for results.'
        redirect_to settings_vulnerability_lookup_path
      rescue StandardError => e
        Rails.logger.error "Failed to queue CVE scan: #{e.message}"
        flash[:error] = "Failed to start scan: #{e.message}"
        redirect_to settings_vulnerability_lookup_path
      end
    end

    private

    def authorize_admin!
      unless current_user.admin?
        flash[:error] = 'You are not authorized to access this page'
        redirect_to root_path
      end
    end

    def sanitize_url(url)
      # Remove trailing slash
      url = url.strip.chomp('/')

      # Add https:// if no protocol specified
      url = "https://#{url}" unless url.start_with?('http://', 'https://')

      # Validate URL format
      uri = URI.parse(url)
      unless uri.is_a?(URI::HTTP) || uri.is_a?(URI::HTTPS)
        raise ArgumentError, 'Invalid URL format'
      end

      url
    rescue URI::InvalidURIError
      raise ArgumentError, 'Invalid URL format'
    end

    def valid_cron_expression?(cron)
      # Basic cron validation: 5 fields separated by spaces
      # Format: minute hour day_of_month month day_of_week
      parts = cron.split(/\s+/)
      return false unless parts.length == 5

      # Each part should be valid (numbers, *, /, -, ,)
      parts.all? { |part| part.match?(/^[\d\*\-\/,]+$/) }
    end

    def get_python_environment_info
      tempfile = nil

      begin
        # Resolve Python path with fallback chain
        python_path = resolve_python_path

        # Return error if no valid Python found
        unless python_path
          return {
            available: false,
            python_path: nil,
            python_version: nil,
            pyvulnerabilitylookup_version: nil,
            message: "Python not configured or missing. Please set Python path in settings."
          }
        end

        # Create inline Python test script
        python_test_script = <<~PYTHON
          import json
          import sys
          try:
              import pyvulnerabilitylookup
              import importlib.metadata
              version = importlib.metadata.version('pyvulnerabilitylookup')

              # Also get Python version
              python_version = f"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}"

              print(json.dumps({
                  'success': True,
                  'version': version,
                  'python_version': python_version
              }))
          except ImportError as e:
              python_version = f"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}"
              print(json.dumps({
                  'success': False,
                  'error': str(e),
                  'python_version': python_version
              }))
              sys.exit(1)
          except Exception as e:
              print(json.dumps({
                  'success': False,
                  'error': str(e)
              }))
              sys.exit(1)
        PYTHON

        # Create temporary file for the script
        tempfile = Tempfile.new(['pyvuln_check', '.py'])
        tempfile.write(python_test_script)
        tempfile.close

        # Execute script with timeout protection
        stdout, stderr, status = Timeout.timeout(120) do
          Open3.capture3(python_path, tempfile.path)
        end

        # Parse JSON output
        begin
          result = JSON.parse(stdout)

          if result['success']
            {
              available: true,
              python_path: python_path,
              python_version: result['python_version'] || 'unknown',
              pyvulnerabilitylookup_version: result['version'],
              message: "Python environment is configured correctly"
            }
          else
            {
              available: false,
              python_path: python_path,
              python_version: result['python_version'] || 'unknown',
              pyvulnerabilitylookup_version: nil,
              message: "PyVulnerabilityLookup is not installed. Run: pip install pyvulnerabilitylookup"
            }
          end
        rescue JSON::ParserError => e
          Rails.logger.error "Failed to parse Python script output: #{stdout}\nError: #{e.message}"
          {
            available: false,
            python_path: python_path,
            python_version: nil,
            pyvulnerabilitylookup_version: nil,
            message: "Failed to parse Python script output. Error: #{stderr.presence || e.message}"
          }
        end
      rescue Timeout::Error
        Rails.logger.error "Python environment check timed out after 120 seconds"
        {
          available: false,
          python_path: python_path,
          python_version: nil,
          pyvulnerabilitylookup_version: nil,
          message: "Python environment check timed out. Please check system load and try again."
        }
      rescue StandardError => e
        Rails.logger.error "Python environment check failed: #{e.message}\n#{e.backtrace.join("\n")}"
        {
          available: false,
          python_path: python_path,
          python_version: nil,
          pyvulnerabilitylookup_version: nil,
          message: "Python environment error: #{e.message}"
        }
      ensure
        tempfile.unlink if tempfile
      end
    end

    def resolve_python_path
      # First try: configured path from SystemSetting
      configured_path = SystemSetting.get('vulnerability_lookup_python_path', '/opt/veracity/app/integrations_venv/bin/python')
      return configured_path if File.exist?(configured_path)

      # Second try: venv path
      venv_path = '/opt/veracity/app/integrations_venv/bin/python'
      return venv_path if File.exist?(venv_path)

      # Third try: system python3
      stdout, stderr, status = Open3.capture3('which', 'python3')
      system_python = stdout.strip
      return system_python if status.success? && system_python.present? && File.exist?(system_python)

      # No valid Python found
      nil
    end

    def restart_scheduler
      # Signal Sidekiq to reload the schedule with user-configured CVE scan schedule
      begin
        # Load base schedule from YAML
        schedule = YAML.load_file(Rails.root.join('config', 'schedule.yml'))

        # Override CVE scan schedule with user configuration
        if schedule['cve_scan']
          user_schedule = SystemSetting.get('vulnerability_lookup_scan_schedule', '0 2 * * *')
          schedule['cve_scan']['cron'] = user_schedule
          Rails.logger.info "Updated CVE scan schedule to: #{user_schedule}"
        end

        # Reload all jobs
        Sidekiq::Cron::Job.load_from_hash!(schedule)
        Rails.logger.info "Sidekiq scheduler reloaded with new CVE scan schedule"
      rescue StandardError => e
        Rails.logger.warn "Could not reload Sidekiq scheduler: #{e.message}"
      end
    end
  end
end
